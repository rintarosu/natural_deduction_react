import type { Formula, ProofState, ProofStep, RuleName } from './types.js';

/**
 * 2„Å§„ÅÆAST„ÅåÊßãÈÄ†ÁöÑ„Å´Âêå‰∏Ä„Åß„ÅÇ„Çã„Åã„Çí„ÉÅ„Çß„ÉÉ„ÇØ„Åô„ÇãÔºà„Éá„Ç£„Éº„ÉóÊØîËºÉÔºâ
 * Âé≥ÂØÜ„Åß„ÅØ„Å™„ÅÑ„Åå„ÄÅÁèæÂú®„ÅÆÂÆüË£Ö„ÇíÊúÄ„ÇÇÁ∞°Âçò„Å´„Åô„ÇãÊñπÊ≥ï„ÄÇ
 * @param f1 Formula 1
 * @param f2 Formula 2
 * @returns Âêå‰∏Ä„Åß„ÅÇ„Çå„Å∞ true
 */
function isFormulaEqual(f1: Formula, f2: Formula): boolean {
    return JSON.stringify(f1) === JSON.stringify(f2);
}

/**
 * „É¶„Éº„Ç∂„Éº„ÅÆÈÅ∏Êäû„Å´Âü∫„Å•„ÅÑ„Å¶„ÄÅÊé®Ë´ñ„ÇíÂÆüË°å„Åô„ÇãÈñ¢Êï∞
 * @param state ÁèæÂú®„ÅÆË®ºÊòéÁä∂ÊÖã
 * @param rule „É¶„Éº„Ç∂„Éº„ÅåÈÅ∏Êäû„Åó„ÅüË¶èÂâá
 * @param selectedStepIds Ë¶èÂâá„ÇíÈÅ©Áî®„Åô„ÇãÂØæË±°„ÅÆË°åÔºàIDÔºâ
 * @returns ÈÅ©Áî®Âæå„ÅÆÊñ∞„Åó„ÅÑË®ºÊòéÁä∂ÊÖã
 */
export function applyRule(
  state: ProofState,
  rule: RuleName,
  selectedStepIds: number[],
  newFormulaAst?: Formula
): ProofState {

    // --- Ë¶èÂâá: „É¢„Éº„ÉÄ„Çπ„Éù„Éç„É≥„Çπ (MP) „ÅÆÈÅ©Áî® ---
    
    // --- Ë¶èÂâá: „É¢„Éº„ÉÄ„Çπ„Éù„Éç„É≥„Çπ (MP) „ÅÆÈÅ©Áî® ---
    if (rule === 'MP') {
        if (selectedStepIds.length !== 2) {
            throw new Error(`MP (Modus Ponens) requires exactly two premises.`);
        }

        const premises = selectedStepIds
            .map(id => state.currentSteps.find(step => step.id === id))
            .filter((step): step is ProofStep => !!step);
        
        if (premises.length !== 2) {
            throw new Error("One or both selected steps were not found.");
        }

        const [p1, p2] = premises;

        // üåü Âá¶ÁêÜ 1: p1„ÅåÂê´ÊÑè (A -> B) „ÅÆÂ†¥Âêà
        if (p1.formula.type === 'BINARY' && p1.formula.connective === 'IMPLIES') {
            const implication = p1.formula; // TypeScript„ÅØ„Åì„Åì„Åß implication „Åå BINARY „Åß„ÅÇ„Çã„Å®Êé®Ë´ñ„Åô„Çã
            const antecedent = p2.formula; 
    
            if (isFormulaEqual(implication.left, antecedent)) {
                // ÁµêË´ñ B „ÇíÂ∞éÂá∫ (implication.right)
                const newFormula = implication.right;
                
                const newStep: ProofStep = {
                    id: state.nextId,
                    formula: newFormula,
                    rule: rule,
                    justification: selectedStepIds,
                    depth: Math.max(p1.depth, p2.depth), 
                };

                return {
                    ...state,
                    currentSteps: [...state.currentSteps, newStep],
                    nextId: state.nextId + 1,
                };
            }
        } 
        
        // üåü Âá¶ÁêÜ 2: p2„ÅåÂê´ÊÑè (A -> B) „ÅÆÂ†¥Âêà
        if (p2.formula.type === 'BINARY' && p2.formula.connective === 'IMPLIES') {
            const implication = p2.formula;
            const antecedent = p1.formula;
    
            if (isFormulaEqual(implication.left, antecedent)) {
                // ÁµêË´ñ B „ÇíÂ∞éÂá∫ (implication.right)
                const newFormula = implication.right;
                
                const newStep: ProofStep = {
                    id: state.nextId,
                    formula: newFormula,
                    rule: rule,
                    justification: selectedStepIds,
                    depth: Math.max(p1.depth, p2.depth), 
                };

                return {
                    ...state,
                    currentSteps: [...state.currentSteps, newStep],
                    nextId: state.nextId + 1,
                };
            }
        }
        
        // Ë¶èÂâá„ÅåÈÅ©Áî®„Åß„Åç„Å™„ÅÑÂ†¥Âêà
        throw new Error('MP: The selected premises do not match the form (A -> B) and A.');
    }

    else if (rule === 'CI') {
        if (selectedStepIds.length !== 2) {
            throw new Error(`CI (Conjunction Introduction) requires exactly two premises.`);
        }

        const premises = selectedStepIds
            .map(id => state.currentSteps.find(step => step.id === id))
            .filter((step): step is ProofStep => !!step);
        
        const [premiseA, premiseB] = premises;
        
        // ÁµêË´ñ A /\ B „ÇíÂ∞éÂá∫ (ÂâçÊèê„ÅÆÈ†ÜÂ∫è„Å´Èñ¢‰øÇ„Å™„Åè A /\ B „Çí‰Ωú„Çã)
        const newFormula: Formula = {
            type: 'BINARY',
            connective: 'AND',
            left: premiseA.formula,
            right: premiseB.formula,
        };
        
        // Êñ∞„Åó„ÅÑ„Çπ„ÉÜ„ÉÉ„Éó„ÇíÁîüÊàê
        const newStep: ProofStep = {
            id: state.nextId,
            formula: newFormula,
            rule: rule,
            justification: selectedStepIds,
            depth: Math.max(premiseA.depth, premiseB.depth),
        };
        
        return {
            ...state,
            currentSteps: [...state.currentSteps, newStep],
            nextId: state.nextId + 1,
        };
    }
    
    // --- Ë¶èÂâá: ÈÄ£Ë®Ä„ÅÆÈô§Âéª (CE_LEFT / CE_RIGHT) „ÅÆÈÅ©Áî® ---
    else if (rule === 'CE_LEFT' || rule === 'CE_RIGHT') {
        if (selectedStepIds.length !== 1) {
            throw new Error(`Conjunction Elimination requires exactly one premise.`);
        }

        const premise = state.currentSteps.find(step => step.id === selectedStepIds[0]);
        
        if (!premise) {
            throw new Error("Selected step was not found.");
        }
        
        // ÂâçÊèê„Åå BINARYÂûã „Åã„Å§ ANDÁµêÂêàÂ≠ê„Åã„ÉÅ„Çß„ÉÉ„ÇØ (A /\ B „ÅÆÂΩ¢Âºè„ÅãÔºü)
        if (premise.formula.type === 'BINARY' && premise.formula.connective === 'AND') {
            
            const newFormula: Formula = rule === 'CE_LEFT' 
                ? premise.formula.left  // Â∑¶ÂÅ¥ (A) „ÇíÂ∞éÂá∫
                : premise.formula.right; // Âè≥ÂÅ¥ (B) „ÇíÂ∞éÂá∫

            const newStep: ProofStep = {
                id: state.nextId,
                formula: newFormula,
                rule: rule,
                justification: selectedStepIds,
                depth: premise.depth,
            };
            
            return {
                ...state,
                currentSteps: [...state.currentSteps, newStep],
                nextId: state.nextId + 1,
            };
        }

        throw new Error('CE: The selected premise must be a Conjunction (A /\\ B).');
    }

    // --- Ë¶èÂâá: ‰∫åÈáçÂê¶ÂÆö„ÅÆÈô§Âéª (DN) „ÅÆÈÅ©Áî® ---
    else if (rule === 'DN') {
        if (selectedStepIds.length !== 1) {
            throw new Error(`DN (Double Negation) requires exactly one premise.`);
        }

        const premise = state.currentSteps.find(step => step.id === selectedStepIds[0]);
        
        if (!premise) {
            throw new Error("Selected step was not found.");
        }
        
        // ÂâçÊèê„Åå 'NOT' „Åã„Å§„ÄÅ„Åù„ÅÆformula„ÇÇ 'NOT' „Åã„ÉÅ„Çß„ÉÉ„ÇØ (¬¨¬¨A „ÅÆÂΩ¢Âºè„ÅãÔºü)
        if (premise.formula.type === 'NOT' && premise.formula.formula.type === 'NOT') {
            
            // ÁµêË´ñ A „ÇíÂ∞éÂá∫ (ÂÜÖÂÅ¥„ÅÆNOT„ÅåÊåÅ„Å§ formula „ÇíÂèñ„ÇäÂá∫„Åô)
            const newFormula: Formula = premise.formula.formula.formula;

            const newStep: ProofStep = {
                id: state.nextId,
                formula: newFormula,
                rule: rule,
                justification: selectedStepIds,
                depth: premise.depth,
            };
            
            return {
                ...state,
                currentSteps: [...state.currentSteps, newStep],
                nextId: state.nextId + 1,
            };
        }

        throw new Error('DN: The selected premise must be a Double Negation (¬¨¬¨A).');
    }
    // --- Ë¶èÂâá: ÈÅ∏Ë®Ä„ÅÆÂ∞éÂÖ• (DI_LEFT / DI_RIGHT) „ÅÆÈÅ©Áî® ---
    else if (rule === 'DI_LEFT' || rule === 'DI_RIGHT') {
        
        if (selectedStepIds.length !== 1) {
            throw new Error(`DI requires exactly one premise (P).`);
        }
        
        // üåü newFormulaAst „ÅåÂºïÊï∞„Å®„Åó„Å¶Ê∏°„Åï„Çå„Å¶„ÅÑ„Çã„Åã„Çí„ÉÅ„Çß„ÉÉ„ÇØ
        if (!newFormulaAst) { 
             throw new Error(`DI requires a secondary formula (Q) to be provided.`);
        }
        
        const premise = state.currentSteps.find(step => step.id === selectedStepIds[0]);
        
        if (!premise) {
            throw new Error("Selected step was not found.");
        }
        
        // ÁµêË´ñ„ÅÆË´ñÁêÜÂºè (P ‚à® Q „Åæ„Åü„ÅØ Q ‚à® P) „ÇíÊ±∫ÂÆö
        const newFormula: Formula = {
            type: 'BINARY',
            connective: 'OR',
            // üåü Ë¶èÂâáÂêç„Å´Âøú„Åò„Å¶Â∑¶Âè≥„ÇíÂàá„ÇäÊõø„Åà„Çã
            // DI_LEFT „Å™„Çâ left: P, right: Q
            left: rule === 'DI_LEFT' ? premise.formula : newFormulaAst, 
            // DI_LEFT „Å™„Çâ right: Q, DI_RIGHT „Å™„Çâ P
            right: rule === 'DI_LEFT' ? newFormulaAst : premise.formula, 
        };
        
        // Êñ∞„Åó„ÅÑ„Çπ„ÉÜ„ÉÉ„Éó„ÇíÁîüÊàê
        const newStep: ProofStep = {
            id: state.nextId,
            formula: newFormula,
            rule: rule, // DI_LEFT „Åæ„Åü„ÅØ DI_RIGHT
            justification: selectedStepIds,
            depth: premise.depth,
        };
        
        return {
            ...state,
            currentSteps: [...state.currentSteps, newStep],
            nextId: state.nextId + 1,
        };
    } 
        
    // --- Ë¶èÂâá: ÈÅ∏Ë®Ä‰∏âÊÆµË´ñÊ≥ï (DS) „ÅÆÈÅ©Áî® ---
   // backend/src/logics/engine.ts (DSË¶èÂâá„ÅÆÈÉ®ÂàÜ)

    // backend/src/logics/engine.ts (DSË¶èÂâá„ÅÆÈÉ®ÂàÜ)

    // --- Ë¶èÂâá: ÈÅ∏Ë®Ä‰∏âÊÆµË´ñÊ≥ï (DS) „ÅÆÈÅ©Áî® ---
    // backend/src/logics/engine.ts (DSË¶èÂâá„ÅÆÈÉ®ÂàÜ)

    // --- Ë¶èÂâá: ÈÅ∏Ë®Ä‰∏âÊÆµË´ñÊ≥ï (DS) „ÅÆÈÅ©Áî® ---
    else if (rule === 'DS') {
        if (selectedStepIds.length !== 2) {
            throw new Error(`DS (Disjunctive Syllogism) requires exactly two premises.`);
        }

        const premises = selectedStepIds
            .map(id => state.currentSteps.find(step => step.id === id))
            .filter((step): step is ProofStep => !!step);
        
        if (premises.length !== 2) {
             throw new Error("One or both selected steps were not found.");
        }

        const [p1, p2] = premises;

        let disjunctionFormulaCandidate: Formula | undefined; // A ‚à® B „ÅÆASTÂÄôË£ú
        let negationFormulaCandidate: Formula | undefined;    // ¬¨X „ÅÆASTÂÄôË£ú
        
        // 1. ÈÅ∏Ë®Ä„Å®Âê¶ÂÆö„ÅÆÂâçÊèê„ÇíÁâπÂÆö„Åô„Çã
        if (p1.formula.type === 'BINARY' && p1.formula.connective === 'OR') {
            disjunctionFormulaCandidate = p1.formula;
            negationFormulaCandidate = p2.formula;
        } else if (p2.formula.type === 'BINARY' && p2.formula.connective === 'OR') {
            disjunctionFormulaCandidate = p2.formula;
            negationFormulaCandidate = p1.formula;
        }

        // 2. Ê†∏ÂøÉ„ÅÆÂûã„Ç¨„Éº„Éâ„Å®„É≠„Ç∏„ÉÉ„ÇØ„ÅÆÂÆüË°å
        if (disjunctionFormulaCandidate 
            && negationFormulaCandidate 
            && disjunctionFormulaCandidate.type === 'BINARY' // ÂÜóÈï∑„Å†„ÅåÂÆâÂÖ®„ÅÆ„Åü„ÇÅ
            && negationFormulaCandidate.type === 'NOT') {
            
            // üåü ÊúÄÁµÇÊâãÊÆµ: Âûã„ÇíÂÆâÂÖ®„Å´Á¢∫ÂÆö„Åï„Åõ„Çã (disjunction „ÅØÁ¢∫ÂÆü„Å´ BINARY Âûã!)
            //    „Åì„Çå„Å´„Çà„Çä„ÄÅ.left „ÇÑ .right „Å´„Ç¢„ÇØ„Çª„ÇπÂèØËÉΩ„Å´„Å™„Çã
            const disjunction = disjunctionFormulaCandidate as { type: 'BINARY', connective: 'OR', left: Formula, right: Formula };
            const negation = negationFormulaCandidate;
            
            const negatedFormula = negation.formula; // Âê¶ÂÆö„Åï„Çå„Å¶„ÅÑ„Çã‰∏≠Ë∫´ (X)
            let conclusion: Formula | null = null; 
            
            // „Ç±„Éº„Çπ 1: Âê¶ÂÆöÂâçÊèê„Åå ¬¨A (ÈÅ∏Ë®Ä„ÅÆÂ∑¶ÂÅ¥) „Å®‰∏ÄËá¥„Åô„ÇãÂ†¥Âêà
            if (isFormulaEqual(disjunction.left, negatedFormula)) {
                conclusion = disjunction.right; // ÁµêË´ñ„ÅØ B
            } 
            // „Ç±„Éº„Çπ 2: Âê¶ÂÆöÂâçÊèê„Åå ¬¨B (ÈÅ∏Ë®Ä„ÅÆÂè≥ÂÅ¥) „Å®‰∏ÄËá¥„Åô„ÇãÂ†¥Âêà
            else if (isFormulaEqual(disjunction.right, negatedFormula)) {
                conclusion = disjunction.left; // ÁµêË´ñ„ÅØ A
            }
            
            if (conclusion) {
                const newStep: ProofStep = {
                    id: state.nextId,
                    formula: conclusion,
                    rule: rule,
                    justification: selectedStepIds,
                    depth: Math.max(p1.depth, p2.depth),
                };
                
                return {
                    ...state,
                    currentSteps: [...state.currentSteps, newStep],
                    nextId: state.nextId + 1,
                };
            }
        }
        
        // Ë¶èÂâá„ÅåÈÅ©Áî®„Åß„Åç„Å™„ÅÑÂ†¥Âêà
        throw new Error('DS: Premises must be (A ‚à® B) and (¬¨A or ¬¨B).');
    }






    // ‰ªä„ÅØMP„Åó„ÅãÂÆüË£Ö„Åó„Å¶„ÅÑ„Å™„ÅÑ„ÅÆ„Åß„ÄÅ‰ªñ„ÅÆË¶èÂâá„ÅØ„Ç®„É©„Éº
    throw new Error(`Rule ${rule} is not yet implemented.`);
}